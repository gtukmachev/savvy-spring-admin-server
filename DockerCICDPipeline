pipeline {
  agent any
  environment {
    SERVICE = "sba"
    SERVICE_FULLNAME = "${JENKINS_ENV}-sm-ui-${SERVICE}"
    PARAMETERS_TEMP_FILE = "${WORKSPACE}/parameters_${BUILD_ID}.json"
    AWS_REGION = "us-east-1"
  }
  options {
    disableConcurrentBuilds()
    ansiColor("xterm")
    timestamps()
  }
  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }
    stage('Build preparations') {
      steps {
        script {
          // calculate GIT lastest commit short-hash
          gitCommitHash = sh(returnStdout: true, script: 'git rev-parse HEAD').trim()
          shortCommitHash = gitCommitHash.take(7)
          timestamp = new Date().format("yyyyMMddHHmm", TimeZone.getTimeZone('UTC'))
          appVersion = sh(returnStdout: true, script: "mvn -q -Dexec.executable=\"echo\" -Dexec.args='\${project.version}' --non-recursive exec:exec").trim()
          gitBranch = scm.branches[0].name
          // calculate a sample version tag
          VERSION = "${appVersion}-${gitBranch}-${shortCommitHash}-${timestamp}"
          // set the build display name
          currentBuild.displayName = "#${BUILD_ID}-${VERSION}"
          IMAGE = "${SERVICE_FULLNAME}:${VERSION}"
        }
      }
    }
    stage('Maven build') {
      steps {
        sh 'mvn clean package'
      }
    }
    stage('Docker build') {
      steps {
        script {
          docker.build("$IMAGE", "--build-arg IMAGE_VERSION=${VERSION} .")
        }
      }
    }
    stage('Docker push') {
      steps {
        script {
          // get repository uri by name
          repoUri = sh(returnStdout: true,
           script: """aws ecr describe-repositories --region ${AWS_REGION} --repository-names ${SERVICE_FULLNAME} |
           jq -r '.repositories[0].repositoryUri'""").trim()
          repoFullUri = "https://${repoUri}"
          withAWS(region: AWS_REGION) {
            loginString = ecrLogin()
            sh(script: loginString)
          }
          docker.withRegistry(repoFullUri) {
            // push image with tag VERSION
            docker.image(IMAGE).push()
            // push image with tag "latest"
            docker.image(IMAGE).push('latest')
          }
          imageId = sh(returnStdout: true, script: "docker images -q $IMAGE").trim()
        }
      }
    }
    stage('Update ECS service'){
      steps {
        script {
          // Get CloudFormation template, parse its Parameters, make JSON file for update-stack action
          // Set Image parameter to Image URL pushed in stage "Docker push", use previous values for all the rest
          sh("""\
            aws cloudformation get-template-summary --region ${AWS_REGION} --stack-name ${SERVICE_FULLNAME} |
            jq --arg image "${repoUri}:${VERSION}" '(.Parameters) | map(if .ParameterKey == "Image" then {ParameterKey: .ParameterKey, ParameterValue: \$image} else  {ParameterKey: .ParameterKey, UsePreviousValue: true} end)' \
            > ${PARAMETERS_TEMP_FILE}""")
          // Update CloudFormation stack with parameters JSON file generated in previous step
          sh("""\
            aws cloudformation update-stack --capabilities CAPABILITY_IAM --stack-name ${SERVICE_FULLNAME} \
            --use-previous-template --parameters file://${PARAMETERS_TEMP_FILE} --region ${AWS_REGION}""")
          echo "Wait until CloudFormation update is complete"
          timeout(time: 20, unit: 'MINUTES'){
            sh("aws cloudformation wait stack-update-complete --stack-name ${SERVICE_FULLNAME} --region ${AWS_REGION}")
          }
        }
      }
    }
  }
  post {
    always {
      // make sure that the Docker image is removed
      sh returnStatus: true,
        script: "docker images --format \'{{.ID}} {{.Repository}}:{{.Tag}}\' | grep ${imageId} | awk \'{print \$2}\' |xargs docker rmi"
      // Delete temporary file
      sh "rm ${PARAMETERS_TEMP_FILE} |true"
    }
    regression {
      emailext attachLog: true,
               recipientProviders: [developers()],
               subject: "The build ${env.JOB_NAME} - ${env.BUILD_DISPLAY_NAME} has failed.",
               body: "The build ${env.JOB_NAME} - ${env.BUILD_DISPLAY_NAME} has failed.\n\nOpen ${env.BUILD_URL}/console for more details"
      // Slack Channel and credentials must be configured globally in Jenkins
      slackSend color: "danger",
                message: "[$JENKINS_ENV] The build ${env.JOB_NAME} - ${env.BUILD_DISPLAY_NAME} has failed.\n\nOpen ${env.BUILD_URL}/console for more details"
    }
    fixed {
      emailext recipientProviders: [developers()],
               subject: "The build ${env.JOB_NAME} - ${env.BUILD_DISPLAY_NAME} has been fixed.",
               body: "The build ${env.JOB_NAME} - ${env.BUILD_DISPLAY_NAME} has fixed.\n\nOpen ${env.BUILD_URL}/console for more details"
      slackSend color: "good",
                message: "[$JENKINS_ENV] The build ${env.JOB_NAME} - ${env.BUILD_DISPLAY_NAME} has fixed.\n\nOpen ${env.BUILD_URL}/console for more details"
    }
  }
}
